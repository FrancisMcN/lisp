<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>~/Documents/GitHub/l/lisp.c.html</title>
<meta name="Generator" content="Vim/9.1">
<meta name="plugin-version" content="vim9.0_v2">
<meta name="syntax" content="c">
<meta name="settings" content="use_css,no_foldcolumn,expand_tabs,pre_wrap,prevent_copy=,use_input_for_pc=none">
<meta name="colorscheme" content="none">
<style>
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #ffffff; }
body { font-family: monospace; color: #000000; background-color: #ffffff; }
* { font-size: 1em; }
.Comment { color: #0000c0; }
.Constant { color: #c00000; }
.Special { color: #c000c0; }
.Statement { color: #af5f00; }
.PreProc { color: #c000c0; }
.Type { color: #008000; }
-->
</style>
</head>
<body>
<pre id='vimCodeElement'>
<span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;</span>

<span class="PreProc">#define BUFF_SIZE </span><span class="Constant">256</span>
<span class="PreProc">#define MAX_FUNC_ARGS </span><span class="Constant">64</span>

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Converts a string to an integer</span>
<span class="Comment"> * @param str</span>
<span class="Comment"> * @return - the parsed integer</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">int</span> str_to_int(<span class="Type">char</span>* str) {
    <span class="Statement">return</span> (<span class="Type">int</span>) strtol(str, &amp;str, <span class="Constant">10</span>);
}

<span class="Comment">/*</span><span class="Comment"> The native object types used by the interpreter </span><span class="Comment">*/</span>
<span class="Type">typedef</span> <span class="Type">enum</span> {NUMBER, SYMBOL, CONS, FUNCTION, NIL} Type;

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * All data used by the interpreter is an 'Object', represented</span>
<span class="Comment"> * using the Object struct below.</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">typedef</span> <span class="Type">struct</span> Object {
    <span class="Type">struct</span> Object* next;
    <span class="Type">struct</span> Object* prev;
    <span class="Type">char</span> marked;
    Type type;
    <span class="Type">union</span> {
        <span class="Type">int</span> num;
        <span class="Type">char</span>* sym;
        <span class="Type">struct</span> Cons {
            <span class="Type">struct</span> Object* car;
            <span class="Type">struct</span> Object* cdr;
        } cons;
        <span class="Type">struct</span> Object* (*fn)(<span class="Type">struct</span> Object** args);
    };
} Object;

<span class="Type">static</span> Object* object_new();
<span class="Type">static</span> <span class="Type">void</span> object_free(Object* obj);
<span class="Type">static</span> Object* number_new(<span class="Type">int</span> num);
<span class="Type">static</span> Object* symbol_new(<span class="Type">char</span>* symbol);
<span class="Type">static</span> Object* function_new(<span class="Type">struct</span> Object* (*fn)(<span class="Type">struct</span> Object** args));

<span class="Type">static</span> <span class="Type">void</span> print(Object* obj);

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Each hash table is an array of MapEntry's. The hash table needs to store</span>
<span class="Comment"> * keys as well as values in order to resolve collisions when they happen.</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">typedef</span> <span class="Type">struct</span> MapEntry {
    <span class="Type">char</span>* key;
    Object* value;
} MapEntry;

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * A Map is an array of MapEntry's with some extra metadata to facilitate</span>
<span class="Comment"> * resizing the map.</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">typedef</span> <span class="Type">struct</span> {
    MapEntry* data;
    <span class="Type">size_t</span> used;
    <span class="Type">size_t</span> size;
} Map;

<span class="Comment">/*</span><span class="Comment"> Pre-declaring some map / hash table function signatures </span><span class="Comment">*/</span>
<span class="Type">static</span> Map* map_new();
<span class="Type">static</span> <span class="Type">void</span> map_put(Map* map, <span class="Type">char</span>* key, Object* obj);
<span class="Type">static</span> Object* map_get(Map* map, <span class="Type">char</span>* key);
<span class="Type">static</span> <span class="Type">void</span> map_resize(Map* map);
<span class="Type">static</span> <span class="Type">void</span> map_free(Map* map);

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * GC is used to implement a mark and sweep garbage collector</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">typedef</span> <span class="Type">struct</span> GC {
    Object* tail;

    Map* env;
} GC;

<span class="Type">static</span> GC* gc_new(Map* env) {
    GC* gc = malloc(<span class="Statement">sizeof</span>(GC));
    gc-&gt;env = env;
    <span class="Statement">return</span> gc;
}

<span class="Type">static</span> <span class="Type">void</span> gc_mark(GC* gc) {

    <span class="Type">size_t</span> i;
    <span class="Type">size_t</span> count = <span class="Constant">0</span>;
    <span class="Type">size_t</span> total = <span class="Constant">0</span>;
    <span class="Comment">/*</span><span class="Comment"> Mark all objects stored in the environment map </span><span class="Comment">*/</span>
    MapEntry* entries = gc-&gt;env-&gt;data;
    <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; gc-&gt;env-&gt;size; i++) {
        <span class="Statement">if</span> (entries[i].key != <span class="Constant">NULL</span>) {
            entries[i].value-&gt;marked = <span class="Constant">1</span>;
            count++;
        }
    }

    Object* temp = gc-&gt;tail;
    <span class="Statement">while</span> (temp != <span class="Constant">NULL</span>) {
        total++;
        temp = temp-&gt;prev;
    }

    printf(<span class="Constant">&quot;marked </span><span class="Special">%zu</span><span class="Constant"> objects out of </span><span class="Special">%zu</span><span class="Constant"> total objects.</span><span class="Special">\n</span><span class="Constant">&quot;</span>, count, total);

}

<span class="Type">static</span> <span class="Type">void</span> gc_sweep(GC* gc) {

    <span class="Type">size_t</span> count = <span class="Constant">0</span>;
    Object* ptr = gc-&gt;tail;

    <span class="Statement">while</span> (ptr != <span class="Constant">NULL</span>) {

        <span class="Comment">/*</span><span class="Comment"> remove unmarked objects </span><span class="Comment">*/</span>
        <span class="Statement">if</span> (!ptr-&gt;marked) {

            <span class="Statement">if</span> (ptr-&gt;prev != <span class="Constant">NULL</span>) {
                <span class="Comment">/*</span><span class="Comment"> Remove object from middle or end of linked list </span><span class="Comment">*/</span>
                ptr-&gt;prev-&gt;next = ptr-&gt;next;
                <span class="Comment">/*</span><span class="Comment"> The tail pointer also has to be updated if we free'd the last object in the list </span><span class="Comment">*/</span>
                <span class="Statement">if</span> (ptr == gc-&gt;tail) {
                    gc-&gt;tail = gc-&gt;tail-&gt;prev;
                }
            } <span class="Statement">else</span> {
                <span class="Comment">/*</span><span class="Comment"> Remove object from start of linked list </span><span class="Comment">*/</span>
                gc-&gt;tail = ptr-&gt;next;
            }

            Object* temp = ptr;
            ptr = ptr-&gt;prev;
            <span class="Comment">/*</span><span class="Comment"> Actually free the object </span><span class="Comment">*/</span>
            object_free(temp);
            count++;

        } <span class="Statement">else</span> {
            ptr = ptr-&gt;prev;
        }

    }

    printf(<span class="Constant">&quot;freed </span><span class="Special">%zu</span><span class="Constant"> objects.</span><span class="Special">\n</span><span class="Constant">&quot;</span>, count);

}

<span class="Type">static</span> <span class="Type">void</span> gc_free(GC* gc) {
    free(gc);
}

<span class="Comment">/*</span><span class="Comment"> Instantiate the global reference to the garbage collector,</span>
<span class="Comment"> * I hate global variables but will allow this one. </span><span class="Comment">*/</span>
<span class="Type">static</span> GC* gc;

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Creates a new Object using malloc, don't forget to free!</span>
<span class="Comment"> * @return - returns a pointer to the heap containing the newly created object</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> Object* object_new() {
    Object* obj = (Object*)malloc(<span class="Statement">sizeof</span>(Object));
    obj-&gt;next = <span class="Constant">NULL</span>;
    obj-&gt;prev = <span class="Constant">NULL</span>;
    obj-&gt;marked = <span class="Constant">0</span>;

    <span class="Statement">if</span> (gc-&gt;tail == <span class="Constant">NULL</span>) {
        gc-&gt;tail = obj;
    } <span class="Statement">else</span> {
        gc-&gt;tail-&gt;next = obj;
        obj-&gt;prev = gc-&gt;tail;
        gc-&gt;tail = obj;
    }

    <span class="Statement">return</span> obj;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Allocates a new number object on the heap</span>
<span class="Comment"> * @param num</span>
<span class="Comment"> * @return - a reference to the number object</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> Object* number_new(<span class="Type">int</span> num) {
    Object* obj = object_new();
    obj-&gt;type = NUMBER;
    obj-&gt;num = num;
    <span class="Statement">return</span> obj;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Allocates a new symbol object on the heap</span>
<span class="Comment"> * @param symbol</span>
<span class="Comment"> * @return - a reference to the symbol object</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> Object* symbol_new(<span class="Type">char</span>* symbol) {
    <span class="Type">unsigned</span> <span class="Type">long</span> len;
    Object* obj = object_new();
    obj-&gt;type = SYMBOL;

    len = strlen(symbol);
    obj-&gt;sym = (<span class="Type">char</span>*)malloc(<span class="Statement">sizeof</span>(<span class="Type">char</span>) * (len + <span class="Constant">1</span>));
    strcpy(obj-&gt;sym, symbol);
    <span class="Statement">return</span> obj;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Allocates a new cons object on the heap</span>
<span class="Comment"> * @param car</span>
<span class="Comment"> * @param cdr</span>
<span class="Comment"> * @return</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> Object* cons_new(Object* car, Object* cdr) {
    Object* obj = object_new();
    obj-&gt;type = CONS;
    obj-&gt;cons.car = car;
    obj-&gt;cons.cdr = cdr;
    <span class="Statement">return</span> obj;
}

<span class="Type">static</span> Object* function_new(<span class="Type">struct</span> Object* (*fn)(<span class="Type">struct</span> Object** args)) {
    Object* obj = object_new();
    obj-&gt;type = FUNCTION;
    obj-&gt;fn = fn;
    <span class="Statement">return</span> obj;
}

<span class="Type">static</span> <span class="Type">void</span> object_free(Object* obj) {

    <span class="Statement">if</span> (obj == <span class="Constant">NULL</span>) {
        <span class="Statement">return</span>;
    }

    <span class="Statement">switch</span> (obj-&gt;type) {
        <span class="Statement">case</span> NUMBER: {
            <span class="Statement">break</span>;
        }
        <span class="Statement">case</span> SYMBOL: {
            free(obj-&gt;sym);
            <span class="Statement">break</span>;
        }
        <span class="Statement">case</span> CONS: {
            <span class="Statement">break</span>;
        }
        <span class="Statement">case</span> FUNCTION: {
            <span class="Statement">break</span>;
        }
        <span class="Statement">case</span> NIL: {
            <span class="Statement">break</span>;
        }
    }

    free(obj);
}

<span class="Comment">/*</span><span class="Comment"> Start of hash table implementation </span><span class="Comment">*/</span>

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Initialises a new map</span>
<span class="Comment"> * @return - returns a new, empty map</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> Map* map_new() {
    <span class="Type">unsigned</span> <span class="Type">long</span> initial_size = <span class="Constant">8</span>;
    Map* map = (Map*)malloc(<span class="Statement">sizeof</span>(Map));
    map-&gt;used = <span class="Constant">0</span>;
    map-&gt;size = initial_size;
    map-&gt;data = malloc(<span class="Statement">sizeof</span>(MapEntry) * initial_size);
    <span class="Statement">return</span> map;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Generates a 'unique' number for a string</span>
<span class="Comment"> * @param key - the string to hash</span>
<span class="Comment"> * @return - a 'unique' number to represent the string</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">size_t</span> hash(<span class="Type">char</span>* key) {
    <span class="Type">int</span> i;
    <span class="Type">size_t</span> hash = <span class="Constant">13</span>;
    <span class="Type">size_t</span> len = strlen(key);
    <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; len; i++) {
        hash = hash * <span class="Constant">31</span> + key[i];
    }
    <span class="Statement">return</span> hash;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Re-sizes a map / hash table, each time doubling the size of the table. The</span>
<span class="Comment"> * table is doubled in size because resizing is an expensive operation, doubling each</span>
<span class="Comment"> * time means the resize operation becomes less and less frequent as the table grows.</span>
<span class="Comment"> * @param map - the map to resize</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">void</span> map_resize(Map* map) {
    <span class="Type">int</span> i;
    <span class="Comment">/*</span><span class="Comment"> Increase map size </span><span class="Comment">*/</span>
    map-&gt;size = map-&gt;size * <span class="Constant">2</span>;
    <span class="Comment">/*</span><span class="Comment"> Allocate empty block of data </span><span class="Comment">*/</span>
    MapEntry* new_data = malloc(<span class="Statement">sizeof</span>(MapEntry) * map-&gt;size);

    <span class="Comment">/*</span><span class="Comment"> Re-hash all the existing data </span><span class="Comment">*/</span>
    MapEntry* old_data = map-&gt;data;
    map-&gt;data = new_data;
    <span class="Type">size_t</span> used = map-&gt;used;
    <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; map-&gt;used; i++) {
        <span class="Statement">if</span> (old_data[i].key != <span class="Constant">NULL</span>) {
            map_put(map, old_data[i].key, old_data[i].value);
        }
    }
    map-&gt;used = used;

    <span class="Comment">/*</span><span class="Comment"> Free old block of memory </span><span class="Comment">*/</span>
    free(old_data);

}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Associates a key with a value in a map / hash table. Automatically resizes</span>
<span class="Comment"> * the map / hash table as necessary, each time doubling the size of the table</span>
<span class="Comment"> * and taking care to re-hash all existing the data.</span>
<span class="Comment"> * @param map - the map to insert the data into</span>
<span class="Comment"> * @param key - the key to associate with the object</span>
<span class="Comment"> * @param obj - the object to be associated with the key</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">void</span> map_put(Map* map, <span class="Type">char</span>* key, Object* obj) {
    <span class="Type">size_t</span> key_len = strlen(key);

    <span class="Statement">if</span> (map-&gt;used == map-&gt;size - <span class="Constant">1</span>) {
        map_resize(map);
    }

    <span class="Type">size_t</span> key_hash = hash(key) % (map-&gt;size - <span class="Constant">1</span>);
    <span class="Statement">if</span> (map-&gt;data[key_hash].key == <span class="Constant">NULL</span>) {
        <span class="Comment">/*</span><span class="Comment"> Found a free space in the hash table, store the data in the map entry </span><span class="Comment">*/</span>
        <span class="Type">char</span>* map_key = malloc(<span class="Statement">sizeof</span>(<span class="Type">char</span>) * key_len + <span class="Constant">1</span>);
        strcpy(map_key, key);
        map-&gt;data[key_hash].key = map_key;
        map-&gt;data[key_hash].value = obj;
    } <span class="Statement">else</span> {
        <span class="Comment">/*</span><span class="Comment"> Found a collision, iterate over the hash table until we find the next</span>
<span class="Comment">           available space </span><span class="Comment">*/</span>
        <span class="Statement">while</span> (map-&gt;data[key_hash].key != <span class="Constant">NULL</span>) {

            <span class="Comment">/*</span><span class="Comment"> If key already exists, overwrite the value and exit </span><span class="Comment">*/</span>
            <span class="Statement">if</span> (strcmp(map-&gt;data[key_hash].key, key) == <span class="Constant">0</span>) {
                map-&gt;data[key_hash].value = obj;
                <span class="Statement">return</span>;
            }

            key_hash += <span class="Constant">1</span>;
            key_hash %= map-&gt;size;

        }
        <span class="Comment">/*</span><span class="Comment"> Finally a free space in the table, store the data in the map entry </span><span class="Comment">*/</span>
        <span class="Type">char</span>* map_key = malloc(<span class="Statement">sizeof</span>(<span class="Type">char</span>) * key_len + <span class="Constant">1</span>);
        strcpy(map_key, key);

        map-&gt;data[key_hash].key = map_key;
        map-&gt;data[key_hash].value = obj;
    }

    map-&gt;used++;

}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Retrieves a value from a hash table</span>
<span class="Comment"> * @param map - the map / hash table to do the lookup in</span>
<span class="Comment"> * @param key - the key to search for</span>
<span class="Comment"> * @return - the object from the map / hash table if it exists, otherwise NULL</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> Object* map_get(Map* map, <span class="Type">char</span>* key) {

    <span class="Type">size_t</span> key_hash = hash(key);
    key_hash = key_hash  % (map-&gt;size - <span class="Constant">1</span>);
    <span class="Statement">if</span> (map-&gt;data[key_hash].key != <span class="Constant">NULL</span>) {
        <span class="Statement">if</span> (strcmp(map-&gt;data[key_hash].key, key) == <span class="Constant">0</span>) {
            <span class="Comment">/*</span><span class="Comment"> Found the item, return the object </span><span class="Comment">*/</span>
            <span class="Statement">return</span> map-&gt;data[key_hash].value;
        }

        <span class="Comment">/*</span><span class="Comment"> Found a collision, iterate over the rest of the table to find the map entry if it exists </span><span class="Comment">*/</span>
        <span class="Statement">while</span> (map-&gt;data[key_hash].key != <span class="Constant">NULL</span>) {

            <span class="Comment">/*</span><span class="Comment"> Found the object after the collision, return the object </span><span class="Comment">*/</span>
            <span class="Statement">if</span> (strcmp(map-&gt;data[key_hash].key, key) == <span class="Constant">0</span>) {
                <span class="Comment">/*</span><span class="Comment"> Found the item, return the object </span><span class="Comment">*/</span>
                <span class="Statement">return</span> map-&gt;data[key_hash].value;
            }

            key_hash += <span class="Constant">1</span>;
            key_hash %= map-&gt;size;

        }

    }

    <span class="Comment">/*</span><span class="Comment"> The value we were looking for isn't in the table </span><span class="Comment">*/</span>
    <span class="Statement">return</span> <span class="Constant">NULL</span>;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Deallocates the memory used by the hash table</span>
<span class="Comment"> * @param map - the table whose memory should be deallocated</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">void</span> map_free(Map* map) {
    <span class="Statement">if</span> (map != <span class="Constant">NULL</span>) {
        free(map-&gt;data);
        free(map);
    }
}

<span class="Comment">/*</span><span class="Comment"> End of hash table implementation </span><span class="Comment">*/</span>

Object* eval(Map* env, Object* obj);

<span class="Type">static</span> Object* car(Object* obj) {
    <span class="Statement">if</span> (obj != <span class="Constant">NULL</span> &amp;&amp; obj-&gt;type == CONS) {
        <span class="Statement">return</span> obj-&gt;cons.car;
    }
    <span class="Statement">return</span> <span class="Constant">NULL</span>;
}

<span class="Type">static</span> Object* cdr(Object* obj) {
    <span class="Statement">if</span> (obj != <span class="Constant">NULL</span> &amp;&amp; obj-&gt;type == CONS) {
        <span class="Statement">return</span> obj-&gt;cons.cdr;
    }
    <span class="Statement">return</span> <span class="Constant">NULL</span>;
}

<span class="Type">static</span> <span class="Type">void</span> print(Object* obj) {

    <span class="Statement">if</span> (obj == <span class="Constant">NULL</span>) {
        printf(<span class="Constant">&quot;nil&quot;</span>);
        <span class="Statement">return</span>;
    }

    <span class="Statement">switch</span> (obj-&gt;type) {
        <span class="Statement">case</span> NUMBER: {
            printf(<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, obj-&gt;num);
            <span class="Statement">break</span>;
        }
        <span class="Statement">case</span> SYMBOL: {
            printf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, obj-&gt;sym);
            <span class="Statement">break</span>;
        }
        <span class="Statement">case</span> CONS: {
            putchar(<span class="Constant">'('</span>);
            Object* temp = obj;
            <span class="Statement">while</span> (temp != <span class="Constant">NULL</span>) {
                print(car(temp));
                <span class="Statement">if</span> (cdr(temp) != <span class="Constant">NULL</span>) {
                    putchar(<span class="Constant">' '</span>);
                }
                temp = cdr(temp);
            }
            putchar(<span class="Constant">')'</span>);
            <span class="Statement">break</span>;
        }
        <span class="Statement">case</span> FUNCTION: {
            printf(<span class="Constant">&quot;</span><span class="Special">%p</span><span class="Constant">&quot;</span>, obj-&gt;fn);
            <span class="Statement">break</span>;
        }
        <span class="Statement">case</span> NIL: {
            <span class="Statement">break</span>;
        }
    }
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Reads up to 256 bytes of stdin into a buffer,</span>
<span class="Comment"> * the buffer is passed into the function using the buff[] parameter.</span>
<span class="Comment"> * @param buff - the buffer to store the data read from stdin</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">void</span> read_stdin(<span class="Type">char</span> buff[]) {
    <span class="Type">char</span>* s = fgets(buff, BUFF_SIZE, <span class="Constant">stdin</span>);
    <span class="Statement">if</span> (s == <span class="Constant">NULL</span>) {
        <span class="Comment">/*</span><span class="Comment"> Failed to read string </span><span class="Comment">*/</span>
        fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;something went wrong, reading string.&quot;</span>);
        exit(<span class="Constant">EXIT_FAILURE</span>);
    }
}

<span class="Comment">/*</span>
<span class="Comment"> * Start of scanning and parsing functions</span>
<span class="Comment"> </span><span class="Comment">*/</span>

<span class="Type">static</span> Object* expr(<span class="Type">char</span>** str);
<span class="Type">static</span> Object* list(<span class="Type">char</span>** str);
<span class="Type">static</span> Object* atom(<span class="Type">char</span>** str);

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Clears the buffer so it can be re-used. Ideally buffers are</span>
<span class="Comment"> * allocated on the stack, re-used and cleared for re-use by this</span>
<span class="Comment"> * function.</span>
<span class="Comment"> * @param buff</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">void</span> clear_buff(<span class="Type">char</span> buff[]) {
    <span class="Type">int</span> i;
    <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; BUFF_SIZE; i++) {
        buff[i] = <span class="Constant">0</span>;
    }
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Determines whether the provided character c is numeric</span>
<span class="Comment"> * @param c</span>
<span class="Comment"> * @return true or false</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">char</span> is_number(<span class="Type">char</span> c) {
    <span class="Statement">if</span> (c &gt;= <span class="Constant">'0'</span> &amp;&amp; c &lt;= <span class="Constant">'9'</span>) {
        <span class="Statement">return</span> <span class="Constant">1</span>;
    }
    <span class="Statement">return</span> <span class="Constant">0</span>;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Returns true if the character is a printable ASCII character</span>
<span class="Comment"> * @param c - the character in question</span>
<span class="Comment"> * @return - true if printable, false if non-printable</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">char</span> is_printable(<span class="Type">char</span> c) {
    <span class="Statement">if</span> (c &gt;= <span class="Constant">33</span> &amp;&amp; c &lt;= <span class="Constant">126</span>) {
        <span class="Statement">return</span> <span class="Constant">1</span>;
    }
    <span class="Statement">return</span> <span class="Constant">0</span>;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Currently almost any character is a valid symbol</span>
<span class="Comment"> * @param c</span>
<span class="Comment"> * @return true or false</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">char</span> is_symbol(<span class="Type">char</span> c) {
    <span class="Statement">if</span> (is_printable(c)) {
        <span class="Statement">switch</span> (c) {
            <span class="Statement">case</span> <span class="Constant">'('</span>:
            <span class="Statement">case</span> <span class="Constant">')'</span>:
            <span class="Statement">case</span> <span class="Special">'\''</span>:
                <span class="Statement">return</span> <span class="Constant">0</span>;
            <span class="Statement">default</span>:
                <span class="Statement">return</span> <span class="Constant">1</span>;
        }
    }
    <span class="Statement">return</span> <span class="Constant">0</span>;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Determines the next token in the input stream and stores</span>
<span class="Comment"> * the generated token in the provided buffer. Buff is allocated</span>
<span class="Comment"> * on the stack.</span>
<span class="Comment"> * @param str - the input stream</span>
<span class="Comment"> * @param buff - the provided buffer</span>
<span class="Comment"> * @return - how many characters of the input stream were consumed</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">char</span> peek(<span class="Type">char</span>** str, <span class="Type">char</span> buff[]) {


    clear_buff(buff);

    <span class="Type">char</span>* temp = *str;
    <span class="Type">char</span> consumed = <span class="Constant">0</span>;
    <span class="Type">char</span> c = *temp;

    <span class="Statement">while</span> (c != <span class="Constant">0</span>) {

        consumed++;
        c = *(temp++);

        <span class="Statement">if</span> (c == <span class="Constant">'('</span>) {
            *buff = <span class="Constant">'('</span>;
            <span class="Statement">break</span>;
        }

        <span class="Statement">if</span> (c == <span class="Constant">')'</span>) {
            *buff = <span class="Constant">')'</span>;
            <span class="Statement">break</span>;
        }

        <span class="Statement">if</span> (is_number(c)) {
            <span class="Statement">while</span> (is_number(c)) {
                consumed++;
                *(buff++) = c;
                c = *(temp++);
            }
            <span class="Statement">break</span>;
        }

        <span class="Statement">if</span> (is_symbol(c)) {
            <span class="Statement">while</span> (is_symbol(c)) {
                consumed++;
                *(buff++) = c;
                c = *(temp++);
            }
            <span class="Statement">break</span>;
        }

    }

    <span class="Statement">return</span> consumed;

}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Like peek() except it advances the input stream after</span>
<span class="Comment"> * producing each token.</span>
<span class="Comment"> * @param str - the input stream</span>
<span class="Comment"> * @param buff - the buffer to contain the token</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">void</span> next(<span class="Type">char</span>** str, <span class="Type">char</span> buff[]) {
    <span class="Type">char</span> consumed = peek(str, buff);
    *str += consumed;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Determines if the string/token in the buffer is an atom</span>
<span class="Comment"> * @param buff - contains a string/token under consideration</span>
<span class="Comment"> * @return - true or false</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">char</span> is_atom(<span class="Type">char</span> buff[]) {
    <span class="Statement">if</span> (is_number(*buff) || is_symbol(*buff)) {
        <span class="Statement">return</span> <span class="Constant">1</span>;
    }
    <span class="Statement">return</span> <span class="Constant">0</span>;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Determines if the string/token in the buffer is an expr, i.e.</span>
<span class="Comment"> * either the beginning of a list or an atom</span>
<span class="Comment"> * @param buff - contains the string/token under consideration</span>
<span class="Comment"> * @return - true or false</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">char</span> is_expr(<span class="Type">char</span> buff[]) {
    <span class="Statement">if</span> (*buff == <span class="Constant">'('</span> || is_atom(buff)) {
        <span class="Statement">return</span> <span class="Constant">1</span>;
    }
    <span class="Statement">return</span> <span class="Constant">0</span>;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Tests the type of an object, just a helper method to</span>
<span class="Comment"> * reduce some duplicated code.</span>
<span class="Comment"> * @param object</span>
<span class="Comment"> * @param obj_type</span>
<span class="Comment"> * @return</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">char</span> is_type(Object* object, Type obj_type) {
    <span class="Statement">if</span> (object != <span class="Constant">NULL</span>) {
        <span class="Statement">return</span> (<span class="Type">char</span>) object-&gt;type == obj_type;
    }
    <span class="Statement">return</span> <span class="Constant">0</span>;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Identifies whether a cons cell represents a special form or not</span>
<span class="Comment"> * @param cons - the cons cell to test</span>
<span class="Comment"> * @return - true if the provided cons cell is a special form</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">char</span> is_special_form(Object* cons) {
    Object* first = car(cons);
    <span class="Statement">if</span> (is_type(first, SYMBOL)) {
        <span class="Type">char</span>* sym = first-&gt;sym;
        <span class="Statement">if</span> (strcmp(sym, <span class="Constant">&quot;quote&quot;</span>) == <span class="Constant">0</span> ||
            strcmp(sym, <span class="Constant">&quot;eval&quot;</span>) == <span class="Constant">0</span> ||
            strcmp(sym, <span class="Constant">&quot;define&quot;</span>) == <span class="Constant">0</span> ||
            strcmp(sym, <span class="Constant">&quot;if&quot;</span>) == <span class="Constant">0</span>) {
            <span class="Statement">return</span> <span class="Constant">1</span>;
            }
    }
    <span class="Statement">return</span> <span class="Constant">0</span>;
}

<span class="Type">static</span> Object* eval_eval_special_form(Map* env, Object* obj) {

    <span class="Statement">return</span> eval(env, eval(env, car(cdr(obj))));
}

<span class="Type">static</span> Object* eval_quote_special_form(Map* env, Object* obj) {
    <span class="Statement">return</span> car(cdr(obj));
}

<span class="Type">static</span> Object* eval_define_special_form(Map* env, Object* obj) {
    Object* name = car(cdr(obj));
    Object* value = car(cdr(cdr(obj)));
    map_put(env, name-&gt;sym, eval(env, value));
    <span class="Statement">return</span> <span class="Constant">NULL</span>;
}

<span class="Type">static</span> Object* eval_if_special_form(Map* env, Object* obj) {
    Object* first = car(obj);
    printf(<span class="Constant">&quot;found if special form</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">return</span> <span class="Constant">NULL</span>;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Evaluates the special form, uses the environment to store side effects</span>
<span class="Comment"> * @param env</span>
<span class="Comment"> * @param obj</span>
<span class="Comment"> * @return</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> Object* eval_special_form(Map* env, Object* obj) {
    Object* first = car(obj);
    <span class="Statement">if</span> (strcmp(first-&gt;sym, <span class="Constant">&quot;quote&quot;</span>) == <span class="Constant">0</span>) {
        <span class="Statement">return</span> eval_quote_special_form(env, obj);
    }
    <span class="Statement">if</span> (strcmp(first-&gt;sym, <span class="Constant">&quot;eval&quot;</span>) == <span class="Constant">0</span>) {
        <span class="Statement">return</span> eval_eval_special_form(env, obj);
    }
    <span class="Statement">if</span> (strcmp(first-&gt;sym, <span class="Constant">&quot;define&quot;</span>) == <span class="Constant">0</span>) {
        <span class="Statement">return</span> eval_define_special_form(env, obj);
    }
    <span class="Statement">if</span> (strcmp(first-&gt;sym, <span class="Constant">&quot;if&quot;</span>) == <span class="Constant">0</span>) {
        <span class="Statement">return</span> eval_if_special_form(env, obj);
    }
    <span class="Statement">return</span> <span class="Constant">NULL</span>;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Evaluates a cons cell representing a function call</span>
<span class="Comment"> * @param env</span>
<span class="Comment"> * @param obj</span>
<span class="Comment"> * @return</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> Object* eval_function_call(Map* env, Object* obj) {
    <span class="Type">int</span> i;
    Object* function = eval(env, car(obj));
    Object* args[MAX_FUNC_ARGS] = {<span class="Constant">0</span>};

    Object* temp = obj;
    i = <span class="Constant">0</span>;
    <span class="Statement">while</span> (car(temp) != <span class="Constant">NULL</span>) {
        temp = cdr(temp);
        args[i++] = eval(env, car(temp));

    }

    <span class="Statement">return</span> function-&gt;fn(args);
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Evaluates a cons cell. In common with many lisps it first checks if it's a special form</span>
<span class="Comment"> * and if not then assumes it's a function call.</span>
<span class="Comment"> * @param env</span>
<span class="Comment"> * @param obj</span>
<span class="Comment"> * @return</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> Object* eval_list(Map* env, Object* obj) {

    <span class="Statement">if</span> (is_special_form(obj)) {
        <span class="Statement">return</span> eval_special_form(env, obj);
    }

    <span class="Statement">return</span> eval_function_call(env, obj);
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Parses a list and produces a cons object.</span>
<span class="Comment"> * list : '(' expr* ')'</span>
<span class="Comment"> * @param str - the input stream</span>
<span class="Comment"> * @return - a cons object</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> Object* list(<span class="Type">char</span>** str) {

    Object* obj = <span class="Constant">NULL</span>;
    <span class="Type">char</span> buff[BUFF_SIZE] = {<span class="Constant">0</span>};
    next(str, buff);

    peek(str, buff);

    Object* temp = cons_new(<span class="Constant">NULL</span>, <span class="Constant">NULL</span>);
    obj = temp;
    Object* prev = temp;
    <span class="Statement">while</span> (is_expr(buff)) {
        temp-&gt;cons.car = expr(str);

        temp-&gt;cons.cdr = cons_new(<span class="Constant">NULL</span>, <span class="Constant">NULL</span>);
        prev = temp;
        temp = temp-&gt;cons.cdr;

        peek(str, buff);
    }

    <span class="Comment">/*</span><span class="Comment"> Remove extra empty cons cell, we don't need to free</span>
<span class="Comment">     * the extra cons cell because we have garbage collection </span><span class="Comment">*/</span>
    prev-&gt;cons.cdr = <span class="Constant">NULL</span>;

    next(str, buff);
    <span class="Statement">return</span> obj;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * atom : Integer | Symbol</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> Object* atom(<span class="Type">char</span>** str) {

    Object* obj = <span class="Constant">NULL</span>;
    <span class="Type">char</span> buff[BUFF_SIZE] = {<span class="Constant">0</span>};
    peek(str, buff);

    <span class="Statement">if</span> (is_number(*buff)) {
        obj = number_new(str_to_int(buff));
    } <span class="Statement">else</span> <span class="Statement">if</span> (is_symbol(*buff)) {
        obj = symbol_new(buff);
    }

    next(str, buff);

    <span class="Statement">return</span> obj;
}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * expr : list | atom</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> Object* expr(<span class="Type">char</span>** str) {
    <span class="Type">char</span> buff[BUFF_SIZE] = {<span class="Constant">0</span>};
    peek(str, buff);
    <span class="Statement">if</span> (strcmp(buff, <span class="Constant">&quot;(&quot;</span>) == <span class="Constant">0</span>) {
       <span class="Comment">/*</span><span class="Comment"> found a list </span><span class="Comment">*/</span>
        <span class="Statement">return</span> list(str);
    } <span class="Statement">else</span> {
       <span class="Comment">/*</span><span class="Comment"> found an atom </span><span class="Comment">*/</span>
        <span class="Statement">return</span> atom(str);
    }
}

Object* parse(<span class="Type">char</span>** str) {
    <span class="Statement">return</span> expr(str);
}

Object* read(<span class="Type">char</span>* str) {
    <span class="Statement">return</span> parse(&amp;str);
}

Object* eval(Map* env, Object* obj) {
    Object* res = <span class="Constant">NULL</span>;
    <span class="Statement">if</span> (obj != <span class="Constant">NULL</span>) {
        <span class="Statement">switch</span> (obj-&gt;type) {
            <span class="Statement">case</span> SYMBOL: {
                res = map_get(env, obj-&gt;sym);
                <span class="Statement">break</span>;
            }
            <span class="Statement">case</span> CONS: {
                res = eval_list(env, obj);
                <span class="Statement">break</span>;
            }
            <span class="Statement">default</span>: {
                res = obj;
                <span class="Statement">break</span>;
            }
        }
    }
    <span class="Statement">return</span> res;
}

<span class="Comment">/*</span>
<span class="Comment"> * End of scanning and parsing functions</span>
<span class="Comment"> </span><span class="Comment">*/</span>

Object* builtin_car(Object* args[]) {
    <span class="Statement">return</span> car(args[<span class="Constant">0</span>]);
}

Object* builtin_cdr(Object* args[]) {
    <span class="Statement">return</span> cdr(args[<span class="Constant">0</span>]);
}

Object* builtin_cons(Object* args[]) {
    <span class="Statement">return</span> cons_new(args[<span class="Constant">0</span>], args[<span class="Constant">1</span>]);
}

Object* builtin_mark(Object* args[]) {
    gc_mark(gc);
    <span class="Statement">return</span> <span class="Constant">NULL</span>;
}

Object* builtin_sweep(Object* args[]) {
    gc_sweep(gc);
    <span class="Statement">return</span> <span class="Constant">NULL</span>;
}

Object* builtin_plus(Object* args[]) {

    <span class="Type">int</span> temp = <span class="Constant">0</span>;
    <span class="Type">int</span> i = <span class="Constant">0</span>;

    <span class="Statement">while</span> (args[i] != <span class="Constant">NULL</span>) {
        Object* arg = args[i];
        temp += arg-&gt;num;
        i++;
    }

    <span class="Statement">return</span> number_new(temp);
}

<span class="Type">static</span> <span class="Type">void</span> init_env(Map* env) {

    map_put(env, <span class="Constant">&quot;car&quot;</span>, function_new(builtin_car));
    map_put(env, <span class="Constant">&quot;cdr&quot;</span>, function_new(builtin_cdr));
    map_put(env, <span class="Constant">&quot;cons&quot;</span>, function_new(builtin_cons));

    map_put(env, <span class="Constant">&quot;gc-mark&quot;</span>, function_new(builtin_mark));
    map_put(env, <span class="Constant">&quot;gc-sweep&quot;</span>, function_new(builtin_sweep));

    map_put(env, <span class="Constant">&quot;+&quot;</span>, function_new(builtin_plus));


}

<span class="Comment">/*</span><span class="Comment">*</span>
<span class="Comment"> * Provides a Read-Eval-Print-Loop to the Lisp interpreter.</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">static</span> <span class="Type">void</span> repl() {
    Object* obj;
    Object* res;
    <span class="Type">char</span> buff[BUFF_SIZE] = {<span class="Constant">0</span>};

    Map* env = map_new();
    gc = gc_new(env);
    init_env(env);

    <span class="Statement">while</span> (strcmp(buff, <span class="Constant">&quot;(exit)&quot;</span>) != <span class="Constant">0</span>) {
        printf(<span class="Constant">&quot;&gt; &quot;</span>);
        read_stdin(buff);

        <span class="Statement">if</span> (buff[<span class="Constant">0</span>] == <span class="Special">'\n'</span>) {
            <span class="Statement">continue</span>;
        }

        obj = read(buff);

        res = eval(env, obj);

        print(res);
        printf(<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

    }

    gc_free(gc);
    map_free(env);

}

<span class="Type">int</span> main(<span class="Type">void</span>) {

    repl();

    <span class="Statement">return</span> <span class="Constant">0</span>;
}
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
